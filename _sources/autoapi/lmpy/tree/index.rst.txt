:mod:`lmpy.tree`
================

.. py:module:: lmpy.tree

.. autoapi-nested-parse::

   Module for the Lifemapper TreeWrapper class.

   .. todo::

      * Should we provide a method to collapse clades that only have one child?
      * Add method to remove annotations.
      * Move label method out of internal functions.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   lmpy.tree.PhyloTreeKeys
   lmpy.tree.TreeWrapper




.. class:: PhyloTreeKeys

   Keys for phylogenetic trees.

   .. attribute:: MTX_IDX

      The tree attribute indicating the matrix index position
      for a node.

      :type: str

   .. attribute:: SQUID

      The tree attribute indicating a hashed identifier for the
      taxon.

      :type: str

   .. attribute:: MTX_IDX
      :annotation: = mx

      

   .. attribute:: SQUID
      :annotation: = squid

      


.. exception:: LmTreeException


   Bases: :py:obj:`Exception`

   Initialize self.  See help(type(self)) for accurate signature.


.. class:: TreeWrapper(*args, **kwargs)


   Bases: :py:obj:`dendropy.Tree`

   The constructor can optionally construct a |Tree| object by
   cloning another |Tree| object passed as the first positional
   argument, or out of a data source if ``stream`` and ``schema`` keyword
   arguments are passed with a file-like object and a schema-specification
   string object values respectively.

   :param \*args: If given, should be exactly one |Tree| object. The new
                  |Tree| will then be a structural clone of this argument.
   :type \*args: positional argument, optional
   :param \*\*kwargs: The following optional keyword arguments are recognized
                      and handled by this constructor:

                          ``label``
                              The label or description of the new |Tree| object.
                          ``taxon_namespace``
                              Specifies the |TaxonNamespace| object to be
                              that the new |Tree| object will reference.
   :type \*\*kwargs: keyword arguments, optional

   .. rubric:: Examples

   Tree objects can be instantiated in the following ways::

       # /usr/bin/env python

       try:
           from StringIO import StringIO
       except ImportError:
           from io import StringIO
       from dendropy import Tree, TaxonNamespace

       # empty tree
       t1 = Tree()

       # Tree objects can be instantiated from an external data source
       # using the 'get()' factory class method

       # From a file-like object
       t2 = Tree.get(file=open('treefile.tre', 'r'),
                       schema="newick",
                       tree_offset=0)

       # From a path
       t3 = Tree.get(path='sometrees.nexus',
               schema="nexus",
               collection_offset=2,
               tree_offset=1)

       # From a string
       s = "((A,B),(C,D));((A,C),(B,D));"
       # tree will be '((A,B),(C,D))'
       t4 = Tree.get(data=s,
               schema="newick")
       # tree will be '((A,C),(B,D))'
       t5 = Tree.get(data=s,
               schema="newick",
               tree_offset=1)
       # passing keywords to underlying tree parser
       t7 = dendropy.Tree.get(
               data="((A,B),(C,D));",
               schema="newick",
               taxon_namespace=t3.taxon_namespace,
               suppress_internal_node_taxa=False,
               preserve_underscores=True)

       # Tree objects can be written out using the 'write()' method.
       t1.write(file=open('treefile.tre', 'r'),
               schema="newick")
       t1.write(path='treefile.nex',
               schema="nexus")

       # Or returned as a string using the 'as_string()' method.
       s = t1.as_string("nexml")

       # tree structure deep-copied from another tree
       t8 = dendropy.Tree(t7)
       assert t8 is not t7                             # Trees are distinct
       assert t8.symmetric_difference(t7) == 0         # and structure is identical
       assert t8.taxon_namespace is t7.taxon_namespace             # BUT taxa are not cloned.
       nds3 = [nd for nd in t7.postorder_node_iter()]  # Nodes in the two trees
       nds4 = [nd for nd in t8.postorder_node_iter()]  # are distinct objects,
       for i, n in enumerate(nds3):                    # and can be manipulated
           assert nds3[i] is not nds4[i]               # independentally.
       egs3 = [eg for eg in t7.postorder_edge_iter()]  # Edges in the two trees
       egs4 = [eg for eg in t8.postorder_edge_iter()]  # are also distinct objects,
       for i, e in enumerate(egs3):                    # and can also be manipulated
           assert egs3[i] is not egs4[i]               # independentally.
       lves7 = t7.leaf_nodes()                         # Leaf nodes in the two trees
       lves8 = t8.leaf_nodes()                         # are also distinct objects,
       for i, lf in enumerate(lves3):                  # but order is the same,
           assert lves7[i] is not lves8[i]             # and associated Taxon objects
           assert lves7[i].taxon is lves8[i].taxon     # are the same.

       # To create deep copy of a tree with a different taxon namespace,
       # Use 'copy.deepcopy()'
       t9 = copy.deepcopy(t7)

       # Or explicitly pass in a new TaxonNamespace instance
       taxa = TaxonNamespace()
       t9 = dendropy.Tree(t7, taxon_namespace=taxa)
       assert t9 is not t7                             # As above, the trees are distinct
       assert t9.symmetric_difference(t7) == 0         # and the structures are identical,
       assert t9.taxon_namespace is not t7.taxon_namespace         # but this time, the taxa *are* different
       assert t9.taxon_namespace is taxa                     # as the given TaxonNamespace is used instead.
       lves3 = t7.leaf_nodes()                         # Leaf nodes (and, for that matter other nodes
       lves5 = t9.leaf_nodes()                         # as well as edges) are also distinct objects
       for i, lf in enumerate(lves3):                  # and the order is the same, as above,
           assert lves7[i] is not lves9[i]             # but this time the associated Taxon
           assert lves7[i].taxon is not lves9[i].taxon # objects are distinct though the taxon
           assert lves7[i].taxon.label == lves9[i].taxon.label # labels are the same.

       # to 'switch out' the TaxonNamespace of a tree, replace the reference and
       # reindex the taxa:
       t11 = Tree.get(data='((A,B),(C,D));', 'newick')
       taxa = TaxonNamespace()
       t11.taxon_namespace = taxa
       t11.reindex_subcomponent_taxa()

       # You can also explicitly pass in a seed node:
       seed = Node(label="root")
       t12 = Tree(seed_node=seed)
       assert t12.seed_node is seed

   .. method:: from_base_tree(cls, tree)
      :classmethod:

      Creates a TreeWrapper object from a base dendropy.Tree.

      :param tree: A base dendropy tree object to wrap into a
                   TreeWrapper.
      :type tree: :obj:`Tree`

      :returns: The newly wrapped tree.
      :rtype: TreeWrapper


   .. method:: from_filename(cls, filename)
      :classmethod:

      Creates a TreeWrapper object by loading a file.

      :param filename: A file path to a tree file that should be loaded.
      :type filename: :obj:`str`

      :returns: The newly loaded tree.
      :rtype: TreeWrapper

      :raises IOError: Raised if the tree file cannot be loaded based on the file
          extension.


   .. method:: add_node_labels(self, prefix=None, overwrite=False)

      Add labels to the nodes in the tree.

      Add labels to the unlabeled nodes in the tree.

      :param prefix: If provided, prefix the node labels
                     with this string.
      :type prefix: :obj:`str`, optional
      :param overwrite: Indicates whether existing node
                        labels should be overwritten or if they should be maintained.
                        Defaults to False.
      :type overwrite: :obj:`bool`, optional

      .. note:: * This labels nodes the way that R does.


   .. method:: annotate_tree(self, annotation_dict, annotation_attribute=None, label_attribute=None, update=False)

      Annotates tree tips and nodes.

      :param annotation_dict: A dictionary where the keys
                              correspond with the node labels and the value is either, a
                              single value, or a dictionary of annotation name keys and
                              annotation value values.
      :type annotation_dict: :obj:`dict`
      :param annotation_attribute: Only used if
                                   annotation_dict contains single values, this will be the name
                                   of the annotation added for each node.  Using None or setting
                                   value to 'label' will change the label of the node.  Defaults
                                   to None.
      :type annotation_attribute: :obj:`str` or None, optional
      :param label_attribute: Use the value of this
                              annotation as the label for the node.  Setting the value to
                              'label' or leaving as None will use the label of the node.
                              Defaults to None.
      :type label_attribute: :obj:`str`, optional
      :param update: If True, update any existing
                     annotations with the annotations provided.  Defaults to False.
      :type update: :obj:`bool`, optional


   .. method:: annotate_tree_tips(self, attribute_name, annotation_pairs, label_attribute='label', update=False)

      Annotates the tips of the tree.

      Deprecated:
          Update to use annotate_tree.

      :param attribute_name: The name of the annotation attribute to add.
      :type attribute_name: :obj:`str`
      :param annotation_pairs: A dictionary of label keys with annotation
                               values.
      :type annotation_pairs: :obj:`dict`
      :param label_attribute: If this is provided, use this
                              annotation attribute as the key instead of the label. Defaults to
                              'label'.
      :type label_attribute: :obj:`str`, optional
      :param update: Defaults to False.  Indicates if existing
                     annotations should be updated.
      :type update: :obj:`bool`, optional


   .. method:: get_annotations(self, annotation_attribute)

      Gets a list of (label, annotation) pairs.

      :param annotation_attribute: The annotation attribute to retrieve.
      :type annotation_attribute: :obj:`str`

      :returns: A list of annotations.
      :rtype: list


   .. method:: get_distance_matrix(self, label_attribute='label', ordered_labels=None)

      Gets a Matrix object of phylogenetic distances.

      Get a Matrix object of phylogenetic distances between tips using a
      lower memory footprint.

      :param label_attribute: The attribute of the tips to use as
                              labels for the matrix.  Defaults to 'label'.
      :type label_attribute: :obj:`str`, optional
      :param ordered_labels: If provided, use this
                             order of labels.
      :type ordered_labels: :obj:`list` of :obj:`str`, optional

      :returns:

                A distance matrix from each tip to each of the other tips
                    in the tree.
      :rtype: Matrix


   .. method:: get_distance_matrix_dendropy(self, label_attribute='label', ordered_labels=None)

      Gets a Matrix object of phylogenetic distances between tips.

      Gets the distance matrix between each tip using Dendropy.

      :param label_attribute: The attribute of the tips to use as
                              labels for the matrix.  Defaults to 'label'.
      :type label_attribute: :obj:`str`, optional
      :param ordered_labels: If provided, use this
                             order of labels.
      :type ordered_labels: :obj:`list` of :obj:`str`, optional

      .. note::

         This method may require a significant amount of memory for large trees.
             The `get_distance_matrix` method has a smaller memory footprint and
             works at nearly the same speed.

      :returns:

                A distance matrix from each tip to each of the other tips in the
                    tree.
      :rtype: Matrix


   .. method:: get_labels(self)

      Gets tip labels for a clade.

      .. note:: Bottom-up order.

      :returns: A list of taxon labels for the taxa in the tree.


   .. method:: get_variance_covariance_matrix(self, label_attribute='label', ordered_labels=None)

      Gets a Matrix object of variance / co-variance for tips in tree.

      :param label_attribute: The attribute of the tips to use as
                              labels for the matrix.  Defaults to 'label'.
      :type label_attribute: :obj:`str`, optional
      :param ordered_labels: If provided, use this
                             order of labels.
      :type ordered_labels: :obj:`list` of :obj:`str`, optional

      :returns:

                A matrix of variance / co-variance values for the tips in
                    the tree.
      :rtype: Matrix

      :raises LmTreeException: If the tree does not have branch lengths.


   .. method:: has_branch_lengths(self)

      Returns a boolean indicating if the entire tree has branch lengths.

      :returns: An indication if the tree has branch lengths.
      :rtype: bool


   .. method:: has_polytomies(self)

      Returns boolean indicating if the tree has polytomies.

      :returns: An indication if the tree has any polytomies.
      :rtype: bool


   .. method:: is_binary(self)

      Checks if the tree is binary.

      :returns: An indication if the tree is binary.
      :rtype: bool

      .. note:: * Checks that every clade has either zero or two children.


   .. method:: is_ultrametric(self, rel_tol=0.001)

      Checks if the tree is ultrametric.

      :param rel_tol: The relative tolerance to determine if the min and
                      max are equal.  We will say they are equal if they are 99.9%.
      :type rel_tol: :obj:`float`

      :returns:

                Returns true if the distance from the root to each tip is the
                    same (within the tolerance interval).
      :rtype: bool

      .. note::

         * To be ultrametric, the branch length from root to tip must be
             equal for all tips.


   .. method:: prune_tips_without_attribute(self, search_attribute=PhyloTreeKeys.MTX_IDX)

      Prunes the tree of any tips that don't have the specified attribute.

      :param search_attribute: The attribute to look for when
                               pruning tips in the tree.  Defaults to PhyloTreeKeys.MTX_IDX.
      :type search_attribute: :obj:`str`, optional


   .. method:: _annotation_method(self, label_attribute)

      Use the label attribute as the node label.

      :param label_attribute: The annotation to use as the label for the
                              nodes in the tree.
      :type label_attribute: :obj:`str`

      :returns: A method for retrieving the label for a taxon.
      :rtype: Method


   .. method:: _annotate_node(self, node, annotation_attribute, annotation_value, update=False)

      Annotates a node with the given value.

      :param node: A node to add an annotation to.
      :type node: :obj:`Node`
      :param annotation_attribute: The annotation attribute to add.  If
                                   None or 'label', update the node label.
      :type annotation_attribute: :obj:`str`
      :param annotation_value: The value of the annotation.
      :type annotation_value: :obj:`object`
      :param update: If True, update existing attribute.
                     Defaults to False.
      :type update: :obj:`bool`, optional


   .. method:: _get_label_method(self, label_attribute)

      Gets the function to be used for retrieving labels.

      :param label_attribute: An annotation name, 'label', or None used to
                              determine which method to use to retrieve the label of a node.
      :type label_attribute: :obj:`str`

      :returns: Function for labeling nodes.


   .. method:: _label_tree_nodes(self, node, i, prefix=None, overwrite=False)

      Private function to do the work when labeling nodes.

      :param node: A node to label.
      :type node: :obj:`Node`
      :param i: A count of the number of previously labeled nodes.
      :type i: :obj:`int`
      :param prefix: A prefix to use when labeling nodes
                     resulting in labels like 'prefix_0'.  Defaults to None and no prefix.
      :type prefix: :obj:`str`, optional
      :param overwrite: Should node labels be overwritten.
                        Defaults to False.
      :type overwrite: :obj:`bool`, optional

      :returns: The number of nodes already labeled in the tree.
      :rtype: int

      .. note:: * Recursive.


   .. method:: _label_method(node)
      :staticmethod:

      Use the label of the node or taxon for the label.

      :param node: The node to get the label for.
      :type node: :obj:`Node`

      :returns: If the node or the node's taxon has a label, return it.
                None: If the node and it's taxon do not have labels.
      :rtype: str



